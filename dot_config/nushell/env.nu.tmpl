# Nushell Environment Configuration
# This file is loaded before config.nu
#
# Note: XDG_CONFIG_HOME is set in .zshenv so nushell knows to look in ~/.config/nushell
# (it needs to be set BEFORE nushell starts)

# Basic environment variables
$env.TERM = "xterm-256color"
$env.EDITOR = "vi"
$env.VISUAL = $env.EDITOR
$env.REACT_EDITOR = $env.VISUAL
$env.CLICOLOR = "1"
$env.PAGER = "less"
$env.LESS = "-F -g -i -M -R -S -w -X -z-4"
$env.WORK_DIR = ($env.HOME | path join "work")
$env.HOMEBREW_NO_AUTO_UPDATE = "1"
$env.NODE_OPTIONS = "{{- default "" .preferences.nodeOptions }}"
$env.GIT_CLEAR_BRANCH_EXCLUDE = "release|develop|main|master|development|production"
$env.FZF_DEFAULT_COMMAND = 'rg --files --no-ignore --hidden --follow -g "!{.git,node_modules}/*" 2> /dev/null'
$env.LANG = "en_US.UTF-8"
$env.LANGUAGE = $env.LANG
$env.LC_ALL = $env.LANG

{{- if .install.golang }}
$env.GOPATH = ($env.WORK_DIR | path join "go")
{{- end }}

# History configuration
$env.HISTFILE = ($env.HOME | path join ".nu_history")

{{- if .install.android }}
{{- if eq .chezmoi.os "darwin" }}
$env.ANDROID_HOME = ($env.HOME | path join "Library/Android/sdk")
{{- end }}
{{- if eq .chezmoi.os "linux" }}
$env.ANDROID_HOME = ($env.HOME | path join "Android/Sdk")
{{- end }}
$env.ANDROID_SDK = $env.ANDROID_HOME
$env.ANDROID_SDK_ROOT = $env.ANDROID_HOME
{{- end }}

# Homebrew setup (manual since brew shellenv doesn't support nushell yet)
{{ if eq .chezmoi.os "darwin" }}
let homebrew_prefix = if ("/opt/homebrew" | path exists) {
    "/opt/homebrew"
} else if ("/usr/local/homebrew" | path exists) {
    "/usr/local/homebrew"
} else {
    null
}
{{ end }}
{{ if eq .chezmoi.os "linux" }}
let homebrew_prefix = if ("/home/linuxbrew/.linuxbrew" | path exists) {
    "/home/linuxbrew/.linuxbrew"
} else if ([$env.HOME, ".linuxbrew"] | path join | path exists) {
    ([$env.HOME, ".linuxbrew"] | path join)
} else {
    null
}
{{ end }}

if $homebrew_prefix != null {
    $env.HOMEBREW_PREFIX = $homebrew_prefix
    $env.HOMEBREW_CELLAR = ([$homebrew_prefix, "Cellar"] | path join)
    $env.HOMEBREW_REPOSITORY = $homebrew_prefix
    $env.MANPATH = ([$homebrew_prefix, "share/man"] | path join)
    $env.INFOPATH = ([$homebrew_prefix, "share/info"] | path join)
}

# PATH management (prepend = higher priority)
# Start with base PATH and build it up
$env.PATH = ($env.PATH | split row (char esep))

# Add homebrew to PATH first (highest priority for system tools)
if $homebrew_prefix != null {
    $env.PATH = ($env.PATH | prepend ([$homebrew_prefix, "bin"] | path join))
    $env.PATH = ($env.PATH | prepend ([$homebrew_prefix, "sbin"] | path join))
}

# User binaries
$env.PATH = ($env.PATH | prepend ([$env.HOME, ".local/bin"] | path join))
$env.PATH = ($env.PATH | prepend ([$env.HOME, ".bin"] | path join))

{{- if .install.golang }}
# Go binaries
$env.PATH = ($env.PATH | prepend ([$env.GOPATH, "bin"] | path join))
{{- end }}

{{- if .install.node }}
# Bun runtime
let bun_bin = ([$env.HOME, ".bun/bin"] | path join)
if ($bun_bin | path exists) {
    $env.PATH = ($env.PATH | prepend $bun_bin)
}
{{- end }}

# GCloud SDK (dynamic detection)
let gcloud_path = (which gcloud | get path.0? | default "" | path dirname)
if ($gcloud_path | is-not-empty) and ($gcloud_path | path exists) {
    $env.PATH = ($env.PATH | prepend $gcloud_path)
}

{{- if .install.android }}
# Android SDK paths
if ($env.ANDROID_HOME? | default "" | is-not-empty) {
    $env.PATH = ($env.PATH | prepend ([$env.ANDROID_HOME, "cmdline-tools/latest/bin"] | path join))
    $env.PATH = ($env.PATH | prepend ([$env.ANDROID_HOME, "emulator"] | path join))
    $env.PATH = ($env.PATH | prepend ([$env.ANDROID_HOME, "tools"] | path join))
    $env.PATH = ($env.PATH | prepend ([$env.ANDROID_HOME, "tools/bin"] | path join))
    $env.PATH = ($env.PATH | prepend ([$env.ANDROID_HOME, "platform-tools"] | path join))
}
{{- end }}

# System paths (append = lower priority)
$env.PATH = ($env.PATH | append "/usr/local/sbin")
$env.PATH = ($env.PATH | append "/usr/local/bin")
$env.PATH = ($env.PATH | append "/sbin")

{{- if .install.rust }}
# Cargo/Rust environment
# Note: Cargo bin path is already in PATH via homebrew/mise
# If you need cargo's env.nu, manually source it in your workflow
# cargo's PATH setup is handled above in the PATH section
{{- end }}

# PKG_CONFIG_PATH setup
if $homebrew_prefix != null {
    $env.PKG_CONFIG_PATH = ([$homebrew_prefix, "lib/pkgconfig"] | path join)
}
{{- if eq .chezmoi.os "linux" }}
let linux_pkg_paths = "/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/share/pkgconfig:/usr/lib/pkgconfig"
if ($env.PKG_CONFIG_PATH? | default "" | is-not-empty) {
    $env.PKG_CONFIG_PATH = ($env.PKG_CONFIG_PATH + ":" + $linux_pkg_paths)
} else {
    $env.PKG_CONFIG_PATH = $linux_pkg_paths
}
{{- end }}

# GPG TTY
$env.GPG_TTY = (tty)

# Mise integration (using autoload pattern)
# NOTE: vendor/autoload must be in $nu.data-dir, not $nu.default-config-dir
if (which mise | is-not-empty) {
    let mise_autoload = ([$nu.data-dir, "vendor/autoload"] | path join)
    mkdir $mise_autoload
    ^mise activate nu | save -f ([$mise_autoload, "mise.nu"] | path join)
}
